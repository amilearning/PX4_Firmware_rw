/*
 * UAVCAN data structure definition for libuavcan.
 *
 * Autogenerated, do not edit.
 *
 * Source file: /home/hojin/drone_ws/ethz_ws/ethzasl_fw_px4/src/drivers/uavcan/libuavcan/libuavcan/test/dsdl_test/root_ns_a/UnionTest4.uavcan
 */

#ifndef ROOT_NS_A_UNIONTEST4_HPP_INCLUDED
#define ROOT_NS_A_UNIONTEST4_HPP_INCLUDED

#include <uavcan/build_config.hpp>
#include <uavcan/node/global_data_type_registry.hpp>
#include <uavcan/marshal/types.hpp>

#include <root_ns_a/Empty.hpp>

/******************************* Source text **********************************
# A union of four items; tag 2 bits wide, total length 1 byte
@union          # 2 bits
Empty first     # Tag value 0
uint5 second    # Tag value 1
uint6 third     # Tag value 2
int2  fourth    # Tag value 3
******************************************************************************/

/********************* DSDL signature source definition ***********************
root_ns_a.UnionTest4
@union
root_ns_a.Empty first
saturated uint5 second
saturated uint6 third
saturated int2 fourth
******************************************************************************/

#undef first
#undef second
#undef third
#undef fourth

namespace root_ns_a
{

template <int _tmpl>
struct UAVCAN_EXPORT UnionTest4_
{
    typedef const UnionTest4_<_tmpl>& ParameterType;
    typedef UnionTest4_<_tmpl>& ReferenceType;

    struct ConstantTypes
    {
    };

    struct FieldTypes
    {
        typedef ::root_ns_a::Empty first;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > second;
        typedef ::uavcan::IntegerSpec< 6, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > third;
        typedef ::uavcan::IntegerSpec< 2, ::uavcan::SignednessSigned, ::uavcan::CastModeSaturate > fourth;
    };

    struct Tag
    {
        enum Type
        {
            first,
            second,
            third,
            fourth
        };
    };

    typedef ::uavcan::IntegerSpec< ::uavcan::IntegerBitLen< 4U - 1U >::Result,
                                   ::uavcan::SignednessUnsigned, ::uavcan::CastModeTruncate > TagType;

    enum
    {
        MinBitLen = TagType::BitLen +
            ::uavcan::EnumMin<FieldTypes::first::MinBitLen,
            ::uavcan::EnumMin<FieldTypes::second::MinBitLen,
            ::uavcan::EnumMin<FieldTypes::third::MinBitLen,
                FieldTypes::fourth::MinBitLen >::Result>::Result>::Result
    };

    enum
    {
        MaxBitLen = TagType::BitLen +
            ::uavcan::EnumMax<FieldTypes::first::MaxBitLen,
            ::uavcan::EnumMax<FieldTypes::second::MaxBitLen,
            ::uavcan::EnumMax<FieldTypes::third::MaxBitLen,
                FieldTypes::fourth::MaxBitLen >::Result>::Result>::Result
    };

    // Constants

    // Fields
    typename ::uavcan::StorageType< typename FieldTypes::first >::Type first;
    typename ::uavcan::StorageType< typename FieldTypes::second >::Type second;
    typename ::uavcan::StorageType< typename FieldTypes::third >::Type third;
    typename ::uavcan::StorageType< typename FieldTypes::fourth >::Type fourth;

private:
    typename ::uavcan::StorageType< TagType >::Type _tag_;  // The name is mangled to avoid clashing with fields

    template <typename Tag::Type T>
    struct TagToType;

public:

    UnionTest4_()
        : first()
        , second()
        , third()
        , fourth()
        , _tag_()
    {
        ::uavcan::StaticAssert<_tmpl == 0>::check();  // Usage check

#if UAVCAN_DEBUG
        /*
         * Cross-checking MaxBitLen provided by the DSDL compiler.
         * This check shall never be performed in user code because MaxBitLen value
         * actually depends on the nested types, thus it is not invariant.
         */
        ::uavcan::StaticAssert<8 == MaxBitLen>::check();
#endif
    }

    bool operator==(ParameterType rhs) const;
    bool operator!=(ParameterType rhs) const { return !operator==(rhs); }

    /**
     * This comparison is based on @ref uavcan::areClose(), which ensures proper comparison of
     * floating point fields at any depth.
     */
    bool isClose(ParameterType rhs) const;

    static int encode(ParameterType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    static int decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    /**
     * Explicit access to the tag.
     * It is safer to use is()/as()/to() instead.
     */
    typename Tag::Type getTag() const { return typename Tag::Type(_tag_); }
    void setTag(typename Tag::Type x) { _tag_ = typename ::uavcan::StorageType< TagType >::Type(x); }

    /**
     * Whether the union is set to the given type.
     * Access by tag; this will work even if there are non-unique types within the union.
     */
    bool is(typename Tag::Type x) const { return typename Tag::Type(_tag_) == x; }

    /**
     * If the union is currently set to the type T, returns pointer to the appropriate field.
     * If the union is set to another type, returns null pointer.
     */
    template <typename Tag::Type T>
    inline const typename TagToType<T>::StorageType* as() const;

    /**
     * Switches the union to the given type and returns a mutable reference to the appropriate field.
     * If the previous type was different, a default constructor will be called first.
     */
    template <typename Tag::Type T>
    inline typename TagToType<T>::StorageType& to();

    /*
     * Static type info
     */
    enum { DataTypeKind = ::uavcan::DataTypeKindMessage };
    // This type has no default data type ID

    static const char* getDataTypeFullName()
    {
        return "root_ns_a.UnionTest4";
    }

    static void extendDataTypeSignature(::uavcan::DataTypeSignature& signature)
    {
        signature.extend(getDataTypeSignature());
    }

    static ::uavcan::DataTypeSignature getDataTypeSignature();

};

/*
 * Out of line struct method definitions
 */

template <int _tmpl>
bool UnionTest4_<_tmpl>::operator==(ParameterType rhs) const
{
    if (_tag_ != rhs._tag_)
    {
        return false;
    }
    if (_tag_ == 0)
    {
        return first == rhs.first;
    }
    if (_tag_ == 1)
    {
        return second == rhs.second;
    }
    if (_tag_ == 2)
    {
        return third == rhs.third;
    }
    if (_tag_ == 3)
    {
        return fourth == rhs.fourth;
    }
    UAVCAN_ASSERT(0);   // Invalid tag
    return false;
}

template <int _tmpl>
bool UnionTest4_<_tmpl>::isClose(ParameterType rhs) const
{
    if (_tag_ != rhs._tag_)
    {
        return false;
    }
    if (_tag_ == 0)
    {
        return ::uavcan::areClose(first, rhs.first);
    }
    if (_tag_ == 1)
    {
        return ::uavcan::areClose(second, rhs.second);
    }
    if (_tag_ == 2)
    {
        return ::uavcan::areClose(third, rhs.third);
    }
    if (_tag_ == 3)
    {
        return ::uavcan::areClose(fourth, rhs.fourth);
    }
    UAVCAN_ASSERT(0);   // Invalid tag
    return false;
}

template <int _tmpl>
int UnionTest4_<_tmpl>::encode(ParameterType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    const int res = TagType::encode(self._tag_, codec, ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    if (self._tag_ == 0)
    {
        return FieldTypes::first::encode(self.first, codec, tao_mode);
    }
    if (self._tag_ == 1)
    {
        return FieldTypes::second::encode(self.second, codec, tao_mode);
    }
    if (self._tag_ == 2)
    {
        return FieldTypes::third::encode(self.third, codec, tao_mode);
    }
    if (self._tag_ == 3)
    {
        return FieldTypes::fourth::encode(self.fourth, codec, tao_mode);
    }
    return -1;          // Invalid tag value
}

template <int _tmpl>
int UnionTest4_<_tmpl>::decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    const int res = TagType::decode(self._tag_, codec, ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    if (self._tag_ == 0)
    {
        return FieldTypes::first::decode(self.first, codec, tao_mode);
    }
    if (self._tag_ == 1)
    {
        return FieldTypes::second::decode(self.second, codec, tao_mode);
    }
    if (self._tag_ == 2)
    {
        return FieldTypes::third::decode(self.third, codec, tao_mode);
    }
    if (self._tag_ == 3)
    {
        return FieldTypes::fourth::decode(self.fourth, codec, tao_mode);
    }
    return -1;          // Invalid tag value
}

template <>
template <>
struct UnionTest4_<0>::TagToType<UnionTest4_<0>::Tag::first>
{
    typedef typename UnionTest4_<0>::FieldTypes::first Type;
    typedef typename ::uavcan::StorageType<Type>::Type StorageType;
};

template <>
template <>
inline const typename UnionTest4_<0>::TagToType< UnionTest4_<0>::Tag::first >::StorageType*
UnionTest4_<0>::as< UnionTest4_<0>::Tag::first >() const
{
    return is(UnionTest4_<0>::Tag::first) ? &first : UAVCAN_NULLPTR;
}

template <>
template <>
inline typename UnionTest4_<0>::TagToType< UnionTest4_<0>::Tag::first >::StorageType&
UnionTest4_<0>::to< UnionTest4_<0>::Tag::first >()
{
    if (_tag_ != 0)
    {
        _tag_ = 0;
        first = typename TagToType< UnionTest4_<0>::Tag::first >::StorageType();
    }
    return first;
}

template <>
template <>
struct UnionTest4_<0>::TagToType<UnionTest4_<0>::Tag::second>
{
    typedef typename UnionTest4_<0>::FieldTypes::second Type;
    typedef typename ::uavcan::StorageType<Type>::Type StorageType;
};

template <>
template <>
inline const typename UnionTest4_<0>::TagToType< UnionTest4_<0>::Tag::second >::StorageType*
UnionTest4_<0>::as< UnionTest4_<0>::Tag::second >() const
{
    return is(UnionTest4_<0>::Tag::second) ? &second : UAVCAN_NULLPTR;
}

template <>
template <>
inline typename UnionTest4_<0>::TagToType< UnionTest4_<0>::Tag::second >::StorageType&
UnionTest4_<0>::to< UnionTest4_<0>::Tag::second >()
{
    if (_tag_ != 1)
    {
        _tag_ = 1;
        second = typename TagToType< UnionTest4_<0>::Tag::second >::StorageType();
    }
    return second;
}

template <>
template <>
struct UnionTest4_<0>::TagToType<UnionTest4_<0>::Tag::third>
{
    typedef typename UnionTest4_<0>::FieldTypes::third Type;
    typedef typename ::uavcan::StorageType<Type>::Type StorageType;
};

template <>
template <>
inline const typename UnionTest4_<0>::TagToType< UnionTest4_<0>::Tag::third >::StorageType*
UnionTest4_<0>::as< UnionTest4_<0>::Tag::third >() const
{
    return is(UnionTest4_<0>::Tag::third) ? &third : UAVCAN_NULLPTR;
}

template <>
template <>
inline typename UnionTest4_<0>::TagToType< UnionTest4_<0>::Tag::third >::StorageType&
UnionTest4_<0>::to< UnionTest4_<0>::Tag::third >()
{
    if (_tag_ != 2)
    {
        _tag_ = 2;
        third = typename TagToType< UnionTest4_<0>::Tag::third >::StorageType();
    }
    return third;
}

template <>
template <>
struct UnionTest4_<0>::TagToType<UnionTest4_<0>::Tag::fourth>
{
    typedef typename UnionTest4_<0>::FieldTypes::fourth Type;
    typedef typename ::uavcan::StorageType<Type>::Type StorageType;
};

template <>
template <>
inline const typename UnionTest4_<0>::TagToType< UnionTest4_<0>::Tag::fourth >::StorageType*
UnionTest4_<0>::as< UnionTest4_<0>::Tag::fourth >() const
{
    return is(UnionTest4_<0>::Tag::fourth) ? &fourth : UAVCAN_NULLPTR;
}

template <>
template <>
inline typename UnionTest4_<0>::TagToType< UnionTest4_<0>::Tag::fourth >::StorageType&
UnionTest4_<0>::to< UnionTest4_<0>::Tag::fourth >()
{
    if (_tag_ != 3)
    {
        _tag_ = 3;
        fourth = typename TagToType< UnionTest4_<0>::Tag::fourth >::StorageType();
    }
    return fourth;
}

/*
 * Out of line type method definitions
 */
template <int _tmpl>
::uavcan::DataTypeSignature UnionTest4_<_tmpl>::getDataTypeSignature()
{
    ::uavcan::DataTypeSignature signature(0xEC2F1B85A1DC8CC8ULL);

    FieldTypes::first::extendDataTypeSignature(signature);
    FieldTypes::second::extendDataTypeSignature(signature);
    FieldTypes::third::extendDataTypeSignature(signature);
    FieldTypes::fourth::extendDataTypeSignature(signature);

    return signature;
}

/*
 * Out of line constant definitions
 */

/*
 * Final typedef
 */
typedef UnionTest4_<0> UnionTest4;

// No default registration

} // Namespace root_ns_a

/*
 * YAML streamer specialization
 */
namespace uavcan
{

template <>
class UAVCAN_EXPORT YamlStreamer< ::root_ns_a::UnionTest4 >
{
public:
    template <typename Stream>
    static void stream(Stream& s, ::root_ns_a::UnionTest4::ParameterType obj, const int level);
};

template <typename Stream>
void YamlStreamer< ::root_ns_a::UnionTest4 >::stream(Stream& s, ::root_ns_a::UnionTest4::ParameterType obj, const int level)
{
    (void)s;
    (void)obj;
    (void)level;
    if (level > 0)
    {
        s << '\n';
        for (int pos = 0; pos < level; pos++)
        {
            s << "  ";
        }
    }
    if (static_cast<int>(obj.getTag()) == 0)
    {
        s << "first: ";
        YamlStreamer< ::root_ns_a::UnionTest4::FieldTypes::first >::stream(s, obj.first, level + 1);
    }
    if (static_cast<int>(obj.getTag()) == 1)
    {
        s << "second: ";
        YamlStreamer< ::root_ns_a::UnionTest4::FieldTypes::second >::stream(s, obj.second, level + 1);
    }
    if (static_cast<int>(obj.getTag()) == 2)
    {
        s << "third: ";
        YamlStreamer< ::root_ns_a::UnionTest4::FieldTypes::third >::stream(s, obj.third, level + 1);
    }
    if (static_cast<int>(obj.getTag()) == 3)
    {
        s << "fourth: ";
        YamlStreamer< ::root_ns_a::UnionTest4::FieldTypes::fourth >::stream(s, obj.fourth, level + 1);
    }
}

}

namespace root_ns_a
{

template <typename Stream>
inline Stream& operator<<(Stream& s, ::root_ns_a::UnionTest4::ParameterType obj)
{
    ::uavcan::YamlStreamer< ::root_ns_a::UnionTest4 >::stream(s, obj, 0);
    return s;
}

} // Namespace root_ns_a

#endif // ROOT_NS_A_UNIONTEST4_HPP_INCLUDED